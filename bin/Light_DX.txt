#define M_PI 3.14159265383
#define EPSILON 0.00001
#define SHADOW_BIAS 0.5


Texture2D DiffTexture     : register( t0 ); //
Texture2D NormalTexture   : register( t1 ); //
Texture2D PosTexture      : register( t2 ); //
Texture2D AOTexture       : register( t3 ); //
Texture2D DepthTexture    : register( t4 ); //

//Sampler
SamplerState samLinear : register( s0 );
SamplerState samShadow : register( s1 );



//samplerCUBE IBL_specular;
//samplerCUBE IBL_diffuse;

cbuffer cbLigth : register( b0 )
{
    float3 Light_pos0;
    float LightIntensity_0;
    //float EmissiveIntensity;
    float4 vViewPosition;

    matrix matView;
    matrix matWorld;
};

cbuffer cbLigthCamera : register( b1 )
{
    matrix View;
	matrix Projection;
};

cbuffer cbInverseMatrix : register( b2 )
{

    matrix inverseMatView;
    
};



struct PS_INPUT 
{
   float4 Position : SV_POSITION;
   float2 TexCoord : TEXCOORD0;
   
};

float3 fresnelSchlick(float3 F0, float cosTheta)
{
  return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);
}

float ndf_GGX(float NdH, float roughness)
{
  float alpha = roughness * roughness;
  float alphaSqr = alpha * alpha;

  float denom = (NdH * NdH) * (alphaSqr - 1.0f) + 1.0f;
  return alphaSqr / (M_PI * denom * denom);
}

float ga_SchlickG1(float cosTheta, float k)
{
  return cosTheta / (cosTheta * (1.0f - k) + k);
}

float ga_SchlickGGX(float cosLi, float cosLo, float roughness)
{
  float r = roughness + 1.0f;
  //Epic suggest using this roughness remaping for analytic lights
  float k = (r * r) / 8.0f;
  return ga_SchlickG1(cosLi, k) * ga_SchlickG1(cosLo, k);
}

float4 ps_main(PS_INPUT Input) : SV_TARGET0
{   
  float gamma = 2.2f;
  float4 posWorld = float4(PosTexture.Sample(samLinear, Input.TexCoord).xyz, 1.0f);
  
   
  float4x4 matWV = mul(matWorld, matView);
   
  float4 normal = NormalTexture.Sample(samLinear, Input.TexCoord);
  float roughness = normal.w;
   
  normal.w = 0;
   
  //return roughness;
   
  float4 diffuse = DiffTexture.Sample(samLinear, Input.TexCoord);
  diffuse.xyz = pow(diffuse.xyz, gamma);
   
  float metallic = diffuse.w;
  diffuse.w = 1;
  //float4 emissive =  pow(EmisTexture.Sample(samLinear, Input.TexCoord), gamma);
  float ao = AOTexture.Sample(samLinear, Input.TexCoord).r;
   
  float3 specular_F0 = lerp(0.04f, diffuse.xyz, metallic);
   
  float3 wvLightPos_0 = mul(Light_pos0, matWV);
  float4 wvViewPosition = mul(vViewPosition.xyz, matWV);
   
   
  float3 LightDir = normalize(wvLightPos_0.xyz - posWorld.xyz);
  float3 ViewDir = normalize(wvViewPosition.xyz - posWorld.xyz);
   

  float NdL = max(0.0f, dot(normal.xyz, LightDir));
  float NdV = max(0.0f, dot(normal.xyz, ViewDir));
   
  float3 Half = normalize(ViewDir + LightDir);
   
  float NdH = max(0.001f, dot(normal.xyz, Half));
  float HdL = saturate(dot(Half, LightDir));
  float HdV = saturate(dot(Half, ViewDir));
   
  float3 Reflect = normalize(reflect(-ViewDir, normal));
   
  float D = ndf_GGX(NdH, roughness);
  float3 F = fresnelSchlick(specular_F0, HdL);
  float G = ga_SchlickGGX(NdL, NdV, roughness);
   
  float3 specular = (D * F *G) / max(EPSILON,(NdL * NdV * 4));
   
   
  //Shadow
  //float4 shadowTest = float4(0,0,0,1);
  float shadow = 1.0f;
  float4 shadowPos =  mul(posWorld, inverseMatView);
  float4 shadowWPos = mul(float4(shadowPos.xyz,1.0f),View);
  float4 shadowClipPos = mul(shadowWPos, Projection);
  shadowClipPos /= shadowClipPos.w;
  float3 shadowTexCoords = 0.5f + (shadowClipPos.xyz * 0.5f);
   
   //return shadowTest;
   shadowTexCoords.y = 1 -shadowTexCoords.y;
   float shadowDepth = DepthTexture.Sample(samLinear, shadowTexCoords).x;
   float currentDepth = shadowTexCoords.z;
   if(currentDepth + SHADOW_BIAS > shadowDepth){
     shadow = 0.0f;
   }
   //shadow = currentDepth + SHADOW_BIAS > shadowDepth ? 0.0f : 1.0f;
   /////////////
   
   // float3 ambientLighting;
   // {
     // float3 F_a = fresnelSchlick(specular, NdV);
     // float3 kd_a = lerp(1.0f - F_a, 0.0f, metallic);
     
     // float mipLevel = (1.0f - roughness * roughness) * 8.0;
     
     // float4 vecReflectionSelected = float4(Reflect, mipLevel);
     // float4 siColor = pow((texCUBElod(IBL_specular, vecReflectionSelected)), gamma);
     // float4 diColor = pow((texCUBE(IBL_diffuse, normal.xyz)), gamma);
     
     // float3 diffuseAmbient = kd_a * diffuse;
     
     // ambientLighting = (specular_F0) + diffuseAmbient;
   // }
   
   //return float4(specular, 1);
   
   // return float4 (pow(
   // (diffuse.xyz * NdL * LightIntensity_0) +      //diffuse
   // //(emissive.xyz * EmissiveIntensity) +          //emissive
   // (specular) +
   // (ambientLighting) * ao                        //specular
   // , 1.0f/gamma), 1);
   
   return float4 (pow(((1 - shadow) * (diffuse.xyz * NdL * LightIntensity_0) + (specular)) * ao , 1.0f/gamma), 1);
   
}
