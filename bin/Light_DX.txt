#define M_PI 3.14159265383
#define EPSILON 0.00001


Texture2D DiffTexture: register( t0 ); //
Texture2D NormalTexture: register( t1 ); //
Texture2D PosTexture : register( t2 ); //
Texture2D AOTexture: register( t3 ); //

//Sampler
SamplerState samLinear : register( s0 );



//samplerCUBE IBL_specular;
//samplerCUBE IBL_diffuse;

cbuffer cbLigth : register( b0 )
{
    float3 Light_pos0;
    float LightIntensity_0;
    //float EmissiveIntensity;
    float4 vViewPosition;

    matrix matView;
    matrix matWorld;
};



struct PS_INPUT 
{
   float4 Position : SV_POSITION;
   float2 TexCoord : TEXCOORD0;
   
};

float3 fresnelSchlick(float3 F0, float cosTheta)
{
  return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);
}

float ndf_GGX(float NdH, float roughness)
{
  float alpha = roughness * roughness;
  float alphaSqr = alpha * alpha;

  float denom = (NdH * NdH) * (alphaSqr - 1.0f) + 1.0f;
  return alphaSqr / (M_PI * denom * denom);
}

float ga_SchlickG1(float cosTheta, float k)
{
  return cosTheta / (cosTheta * (1.0f - k) + k);
}

float ga_SchlickGGX(float cosLi, float cosLo, float roughness)
{
  float r = roughness + 1.0f;
  //Epic suggest using this roughness remaping for analytic lights
  float k = (r * r) / 8.0f;
  return ga_SchlickG1(cosLi, k) * ga_SchlickG1(cosLo, k);
}

float4 ps_main(PS_INPUT Input) : SV_TARGET0
{   
   float gamma = 2.2f;
   float4 posWorld = PosTexture.Sample(samLinear, Input.TexCoord);
   
   float4x4 matWV = mul(matWorld, matView);
   
   float4 normal = NormalTexture.Sample(samLinear, Input.TexCoord);
   float roughness = normal.w;
   
   normal.w = 0;
   
   //return roughness;
   
   float4 diffuse = DiffTexture.Sample(samLinear, Input.TexCoord);
   diffuse.xyz = pow(diffuse.xyz, gamma);
   
   float metallic = diffuse.w;
   diffuse.w = 1;
   //float4 emissive =  pow(EmisTexture.Sample(samLinear, Input.TexCoord), gamma);
   float ao = AOTexture.Sample(samLinear, Input.TexCoord).r;
   
   float3 specular_F0 = lerp(0.04f, diffuse.xyz, metallic);
   
   float3 wvLightPos_0 = mul(Light_pos0, matWV);
   float4 wvViewPosition = mul(vViewPosition.xyz, matWV);
   
   
   float3 LightDir = normalize(wvLightPos_0.xyz - posWorld.xyz);
   float3 ViewDir = normalize(wvViewPosition.xyz - posWorld.xyz);
   

   float NdL = max(0.0f, dot(normal.xyz, LightDir));
   float NdV = max(0.0f, dot(normal.xyz, ViewDir));
   
   float3 Half = normalize(ViewDir + LightDir);
   
   float NdH = max(0.001f, dot(normal.xyz, Half));
   float HdL = saturate(dot(Half, LightDir));
   float HdV = saturate(dot(Half, ViewDir));
   
   float3 Reflect = normalize(reflect(-ViewDir, normal));
   
   float D = ndf_GGX(NdH, roughness);
   float3 F = fresnelSchlick(specular_F0, HdL);
   float G = ga_SchlickGGX(NdL, NdV, roughness);
   
   float3 specular = (D * F *G) / max(EPSILON,(NdL * NdV * 4));
   
   // float3 ambientLighting;
   // {
     // float3 F_a = fresnelSchlick(specular, NdV);
     // float3 kd_a = lerp(1.0f - F_a, 0.0f, metallic);
     
     // float mipLevel = (1.0f - roughness * roughness) * 8.0;
     
     // float4 vecReflectionSelected = float4(Reflect, mipLevel);
     // float4 siColor = pow((texCUBElod(IBL_specular, vecReflectionSelected)), gamma);
     // float4 diColor = pow((texCUBE(IBL_diffuse, normal.xyz)), gamma);
     
     // float3 diffuseAmbient = kd_a * diffuse;
     
     // ambientLighting = (specular_F0) + diffuseAmbient;
   // }
   
   //return float4(specular, 1);
   
   // return float4 (pow(
   // (diffuse.xyz * NdL * LightIntensity_0) +      //diffuse
   // //(emissive.xyz * EmissiveIntensity) +          //emissive
   // (specular) +
   // (ambientLighting) * ao                        //specular
   // , 1.0f/gamma), 1);
   
   return float4 (pow(
   ((diffuse.xyz * NdL * LightIntensity_0) +      //diffuse
   (specular)) * ao                        //specular
   , 1.0f/gamma), 1);
   
}
